import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
from tensorflow import keras
from tensorflow.keras import layers
import tensorflow.keras.backend as K
from scipy.io import loadmat
#from scipy.integrate import simps
from sklearn.metrics import mean_absolute_error
from sklearn.metrics import mean_squared_error
from sklearn.metrics import r2_score
from google.colab import drive
drive.mount('/gdrive')
!ln -s "/gdrive/My Drive/NN Observer"
Iqx=loadmat('/content/NN Observer/noisy_Iq1.mat')
T_obsx=loadmat('/content/NN Observer/observer_Torque.mat')
speedx=loadmat('/content/NN Observer/speed_SMC.mat')
timex=loadmat('/content/NN Observer/sim_time.mat')
Tempx=loadmat('/content/NN Observer/Temperature_Profile.mat')
Iq=Iqx['noisy_Iq'][:,0]
T_obs=T_obsx['Troque_obs'][:,0]
speed=speedx['speed_sm'][:,0]
time=timex['sim_time'][:,0]
Temp=Tempx['Temperature_profile'][:,0]
x1=np.array(Iq)
#x2=np.hstack((np.array(speed),np.zeros(x1.size-np.array(speed).size)))
x2=np.array(speed)
x3=np.array(Temp)
y=np.array(T_obs)
X=np.transpose(np.stack((x1,x2,x3)))
print(X.shape)
print(y.shape)
def physics_loss(y_true, y_pred):
    iq_input, omega_input = y_true[:, 0], y_true[:, 1]
    flux=0.192
    p=4
    F=0.001889
    J=0.011
    dw=tf.experimental.numpy.diff(omega_input)
    last_value = dw[-1:]
    diff_padded = tf.concat([dw, last_value], axis=0)
    # Compute physics-based torque
    physics_torque = (3/2) * p * flux * iq_input - F * omega_input

    # Reshape physics_torque to match y_pred
    physics_torque = tf.reshape(physics_torque, tf.shape(y_pred))

    # Compute physics loss (difference between predicted and physics-based torque)
    return tf.reduce_mean(tf.square(y_pred - physics_torque))
def MSE_loss(y_true, y_pred):
  obs_T=y_true[:,2]
  obs_T = tf.reshape(y_true[:,2], tf.shape(y_pred))
  return tf.reduce_mean(tf.square(y_pred - obs_T))
model = keras.Sequential([
   keras.layers.Dense(8, activation='relu', input_shape=(2,)),
   keras.layers.Dense(4, activation='relu'),
   keras.layers.Dense(1)  # Output layer for torque prediction
])
# --- Combine Losses: MSE + Physics Loss ---
def combined_loss(y_true, y_pred):
    mse_loss =MSE_loss(y_true, y_pred)# K.mean(K.square(y_pred - y_true[:,2]))  # MSE on torque
    phys_loss = physics_loss(y_true, y_pred)  # Physics-based loss
    return mse_loss + phys_loss  # Weighting factor (adjustable)
# --- Compile Model ---
model.compile(optimizer=keras.optimizers.Adam(learning_rate=0.001),
              loss=combined_loss)
X_train = np.column_stack((x1, x2))  # Input features
y_train = np.column_stack((x1, x2, T_obs))  # Include iq, omega, and true torque
# --- Train Model ---
history =model.fit(X_train, y_train, epochs=50, batch_size=32, verbose=1)
loss = history.history['loss']  # Replace 'loss' with the name of your loss metric (e.g., 'mse' or 'mae')
# Create a list of epochs for the x-axis
epochs = range(1, len(loss) + 1)
# Plot the loss function
plt.figure(figsize=(10, 6))
plt.plot(epochs, loss, 'b', label='Training Loss')
plt.title('Training Loss of PINN Model')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
plt.grid(True)
plt.show()
T_pred=model.predict(X_train)
print(T_pred.shape)
import pandas as pd
import numpy as np
data = np.array(loss)

# Convert the NumPy array to a Pandas DataFrame
df = pd.DataFrame(data)

# Define the Excel file name
excel_file_name = 'loss.xlsx'

# Use the to_excel method to save the DataFrame to an Excel file
df.to_excel(excel_file_name, index=False)  # Set index=False to exclude the index column

print(f'Data saved to {excel_file_name}')
import pandas as pd
import numpy as np
data = np.array(y_pre)#np.array(loss)

# Convert the NumPy array to a Pandas DataFrame
df = pd.DataFrame(data)

# Define the Excel file name
excel_file_name = 'train.xlsx'

# Use the to_excel method to save the DataFrame to an Excel file
df.to_excel(excel_file_name, index=False)  # Set index=False to exclude the index column

print(f'Data saved to {excel_file_name}')
mae = mean_absolute_error(y, y_pre)
mse = mean_squared_error(y, y_pre)
rmse = np.sqrt(mse)
r2 = r2_score(y, y_pre)

# Print or use the regression metrics
print("Training Mean Absolute Error:", mae)
print("Training Mean Squared Error:", mse)
print("Training Root Mean Squared Error:", rmse)
print("Training R-squared (R²):", r2)
Iqx=loadmat('/content/NN Observer/Validation_data/Actual_Iq.mat')
T_obsx=loadmat('/content/NN Observer/Validation_data/Troque_obs.mat')
speedx=loadmat('/content/NN Observer/Validation_data/speed_SMC.mat')
Tempx=loadmat('/content/NN Observer/Validation_data/val_temp.mat')
Iq=Iqx['Actual_Iq'][:,0]
T_obs=T_obsx['Troque_obs'][:,0]
speed=speedx['speed_SMC'][:,0]
Iq=Iqx['Actual_Iq'][:,0]
T_obs=T_obsx['Troque_obs'][:,0]
speed=speedx['speed_SMC'][:,0]
Temp=Tempx['Temp_val'][:,0]+30
Y_test=np.transpose(np.array(T_obs))
flux=0.192
p=4
F=0.001889
J=0.011
speed=speed
Iq=Iq
physics_torque = (3/2) * p * flux * Iq - F * speed
x1=np.array(Iq)
#x2=np.hstack((np.array(speed),np.zeros(x1.size-np.array(speed).size)))
x2=np.array(speed)
x3=np.array(Temp)
X_test=np.transpose(np.stack((x1,x2)))
print(X_test.shape)
# Validation
T_pred=model.predict(X_test)
T=np.array(T_pred)
Y_predict=T
time_val=np.linspace(0,596,Y_predict.size)
plt.plot(time_val,Y_predict,label='Predicted Load Torque [Nm]')
plt.plot(time_val,physics_torque,linestyle='dashed',label='Actual Load Torque [Nm]')
plt.title('PCNN Torque Observer Validation')
plt.xlabel('Time [sec]')
plt.ylabel('Torque [Nm]')
plt.grid('on')
plt.legend()
plt.show()
# Validation
mae = mean_absolute_error(physics_torque, Y_predict)
mse = mean_squared_error(physics_torque, Y_predict)
rmse = np.sqrt(mse)
r2 = r2_score(physics_torque, Y_predict)

# Print or use the regression metrics
print("Validation Mean Absolute Error:", mae)
print("Validation Mean Squared Error:", mse)
print("Validation Root Mean Squared Error:", rmse)
print("Validation R-squared (R²):", r2)
import pandas as pd
import numpy as np
data = Y_predict

# Convert the NumPy array to a Pandas DataFrame
df = pd.DataFrame(data)

# Define the Excel file name
excel_file_name = 'validation.xlsx'

# Use the to_excel method to save the DataFrame to an Excel file
df.to_excel(excel_file_name, index=False)  # Set index=False to exclude the index column

print(f'Data saved to {excel_file_name}')
# Parameters
amplitude1 = 200    # Amplitude of the sine wave
amplitude2 = 20    # Amplitude of the sine wave
frequency = 0.05    # Frequency in Hz
sampling_rate = 100  # Samples per second
duration = 200     # Duration in seconds
# Time vector
time = np.linspace(0, duration, int(sampling_rate * duration), endpoint=False)

# Generate the sine wave
speed_validate = abs(amplitude1 * np.sin(2 * np.pi * frequency * time))
current_validate = abs(amplitude2 * np.sin(2 * np.pi * frequency * time))
physics_torque = (3/2) * p * flux * current_validate - F * speed_validate
x1=np.array(current_validate)
x2=np.array(speed_validate)
X_test=np.transpose(np.stack((x1,x2)))
T_pred=model.predict(X_test)
T=np.array(T_pred)
Y_predict=T
time_val=np.linspace(0,596,Y_predict.size)
plt.plot(time_val,Y_predict,label='Predicted Load Torque [Nm]')
plt.plot(time_val,physics_torque,linestyle='dashed',label='Actual Load Torque [Nm]')
plt.title('PCNN Torque Observer Validation')
plt.xlabel('Time [sec]')
plt.ylabel('Torque [Nm]')
plt.grid('on')
plt.legend()
plt.show()
# Validation
mae = mean_absolute_error(physics_torque, Y_predict)
mse = mean_squared_error(physics_torque, Y_predict)
rmse = np.sqrt(mse)
r2 = r2_score(physics_torque, Y_predict)

# Print or use the regression metrics
print("Validation Mean Absolute Error:", mae)
print("Validation Mean Squared Error:", mse)
print("Validation Root Mean Squared Error:", rmse)
print("Validation R-squared (R²):", r2)
import pandas as pd
import numpy as np
data = Y_predict

# Convert the NumPy array to a Pandas DataFrame
df = pd.DataFrame(data)

# Define the Excel file name
excel_file_name = 'validation_sinu.xlsx'

# Use the to_excel method to save the DataFrame to an Excel file
df.to_excel(excel_file_name, index=False)  # Set index=False to exclude the index column

print(f'Data saved to {excel_file_name}')