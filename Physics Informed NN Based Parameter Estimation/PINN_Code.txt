import torch
import torch.nn as nn
import torch.optim as optim
from scipy.io import loadmat
#from scipy.integrate import simps
from sklearn.metrics import mean_absolute_error
from sklearn.metrics import mean_squared_error
from sklearn.metrics import r2_score
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from torch.utils.data import DataLoader, TensorDataset
from google.colab import drive
drive.mount('/gdrive')
Iqx=loadmat('/content/PINN_ParameterEstimation/LBC_iq_Fd_IPMSM.mat')
Idx=loadmat('/content/PINN_ParameterEstimation/LBC_id_Fd_IPMSM.mat')
Vqx=loadmat('/content/PINN_ParameterEstimation/LBC_vq_Fd_IPMSM.mat')
Vdx=loadmat('/content/PINN_ParameterEstimation/LBC_vd_Fd_IPMSM.mat')
Tx=loadmat('/content/PINN_ParameterEstimation/LBC_time_Fd_IPMSM.mat')
Omegax=loadmat('/content/PINN_ParameterEstimation/LBC_omega_e_Fd_IPMSM.mat')
q=Iqx['LBC_iq'][:,0]
Id=Idx['LBC_id'][:,0]
Vq=Vqx['LBC_vq'][:,0]
Vd=Vdx['LBC_vd'][:,0]
Time=Tx['LBC_time'][:,0]
Omega=Omegax['LBC_omega_e'][:,0]
vd=torch.tensor(Vd,dtype=torch.float32,requires_grad=True)
vq= torch.tensor(Vq,dtype=torch.float32,requires_grad=True)
omega= torch.tensor(Omega,dtype=torch.float32,requires_grad=True)
time= torch.tensor(Time,dtype=torch.float32,requires_grad=True)
id_true= torch.tensor(Id,dtype=torch.float32)
iq_true= torch.tensor(Iq,dtype=torch.float32)
data = {
    'vd': vd, 'vq': vq, 'omega': omega,
    'time': time, 'id_true': id_true, 'iq_true': iq_true
}
class PINN(nn.Module):
    def __init__(self):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(4, 64), nn.Tanh(),
            nn.Linear(64, 64), nn.Tanh(),
            nn.Linear(64, 64), nn.Tanh(),
            nn.Linear(64, 64), nn.Tanh(),
            nn.Linear(64, 2)
        )
        self.Ld_raw = nn.Parameter(torch.tensor(0.001))
        self.Lq_raw = nn.Parameter(torch.tensor(0.001))
        self.R_raw = nn.Parameter(torch.tensor(0.01))
    def forward(self, vd, vq, omega, t):
      # Reshape the inputs to have 2 dimensions
        vd = vd.unsqueeze(1)  # Add a dimension along columns
        vq = vq.unsqueeze(1)
        omega = omega.unsqueeze(1)
        t = t.unsqueeze(1)
        x = torch.cat([vd, vq, omega, t], dim=1)
        out = self.net(x)
        return out[:, 0].squeeze(), out[:, 1].squeeze()  # Squeeze to remove extra dimension
    def get_params(self):
        Ld = torch.abs(self.Ld_raw)
        Lq = torch.abs(self.Lq_raw)
        R = torch.abs(self.R_raw)
        return Ld, Lq, R
epochs=1000
lr=0.001
model = PINN()
mse_fn = nn.MSELoss()
optimizer = optim.Adam(model.parameters(), lr=lr)
loss_log = []
mse_log = []
phys_log = []
param_log = []
for epoch in range(epochs):
    optimizer.zero_grad()
    time.requires_grad_(True)
    id_pred, iq_pred = model(vd, vq, omega, time)
    mse_loss_val = mse_fn(id_pred, data['id_true']) + mse_fn(iq_pred, data['iq_true'])
    did_dt = torch.autograd.grad(id_pred, time, torch.ones_like(id_pred), create_graph=True)[0]
    diq_dt = torch.autograd.grad(iq_pred, time, torch.ones_like(iq_pred), create_graph=True)[0]
    Ld, Lq, R = model.get_params()
    vd_phys = R * id_pred + Ld * did_dt - omega * Lq * iq_pred
    vq_phys = R * iq_pred + Lq * diq_dt + omega * Ld * id_pred+ omega * 0.192
    physics_loss_val = mse_fn(vd_phys,data['vd'])+ mse_fn(vq_phys,data['vq'])
    loss = mse_loss_val + 5*physics_loss_val  # Define 'loss'
    loss.backward()
    optimizer.step()
    loss_log.append(loss.item())
    mse_log.append(mse_loss_val.item())
    phys_log.append(physics_loss_val.item())
    param_log.append([Ld.item(), Lq.item(), R.item()])
    print(f"Epoch {epoch}, Total Loss: {loss.item()}, Physics Loss: {physics_loss_val.item()}, MSE Loss: {mse_loss_val.item()}")
    print(f"Estimated Parameters (R_s, L_d, L_q):", {R.item(), Ld.item(), Lq.item()})

    # Print learned parameters
print("\nLearned PMSM Parameters:")
print(f"Rs: {R.item()}")
print(f"Ld: {Ld.item()}")
print(f"Lq: {Lq.item()}")
# ----- Save to Excel -----
df_losses = pd.DataFrame({
    'Epoch': list(range(epochs)),
    'Total Loss': loss_log,
    'MSE Loss': mse_log,
    'Physics Loss': phys_log
})

df_params = pd.DataFrame(param_log, columns=['Ld', 'Lq', 'R'])
df_params['Epoch'] = list(range(epochs))

output_file = "pinn_training_results.xlsx"
with pd.ExcelWriter(output_file) as writer:
    df_losses.to_excel(writer, sheet_name='Losses', index=False)
    df_params.to_excel(writer, sheet_name='Parameters', index=False)

# ----- Plotting -----
plt.figure(figsize=(10, 5))
plt.plot(df_losses['Epoch'], df_losses['Total Loss'], label='Total Loss')
plt.plot(df_losses['Epoch'], df_losses['MSE Loss'], label='MSE Loss')
plt.plot(df_losses['Epoch'], df_losses['Physics Loss'], label='Physics Loss')
plt.title('Losses During Training')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 5))
plt.plot(df_params['Epoch'], np.full_like(df_params['R'], 0.05), label='Actual R')
plt.plot(df_params['Epoch'], df_params['R'], label='Learned R')
plt.title('R_{s} Estimation During Training')
plt.xlabel('Epoch')
plt.ylabel('Parameter Value')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 5))
plt.plot(df_params['Epoch'],  np.full_like(df_params['Lq'], 0.0021), label='Actual L_{q}')
plt.plot(df_params['Epoch'], df_params['Lq'], label='Learned L_{q}')
plt.title('L_{q} Estimation During Training')
plt.xlabel('Epoch')
plt.ylabel('Parameter Value')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 5))
plt.plot(df_params['Epoch'],  np.full_like(df_params['Ld'], 0.0015), label='Actual L_{q}')
plt.plot(df_params['Epoch'], df_params['Ld'], label='Learned Ld')
plt.title('L_{q} Estimation During Training')
plt.xlabel('Epoch')
plt.ylabel('Parameter Value')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()
print(f"Excel file saved at: {output_file}")
